}
plotTYPE <- function (x,y,z){
typ = type(x,y,z)
xl = c(min(x[1], y[1], z[1]),max(x[1], y[1], z[1]) )
yl = c(min(x[2], y[2], z[2]),max(x[2], y[2], z[2]) )
trLine = c()
t = seq(0,1, length.out = 200)
for (ti in t){
trLine = rbind(trLine, tropicalLine(x,y,ti))
}
plot(trLine[,1], trLine[,2], type = 'l', col = 'red', xlim = xl, ylim = yl, main = paste("Type", typ))
trLine = c()
for (ti in t){
trLine = rbind(trLine, tropicalLine(y,z,ti))
}
lines(trLine[,1], trLine[,2], type = 'l', col = 'blue' )
trLine = c()
for (ti in t){
trLine = rbind(trLine, tropicalLine(x,z,ti))
}
lines(trLine[,1], trLine[,2], type = 'l', col = 'green')
points(x[1], x[2], pch = 16)
points(y[1], y[2], pch = 16)
points(z[1], z[2], pch = 16)
}
for (j in 1:10){
x = sample(0:10, size = 2, replace = TRUE)
y  = sample(c(0:10), size = 2, replace = TRUE)
z  = sample(c(0:10), size = 2, replace = TRUE)
while ((identical(x,y)) | (identical(x,z)) | (identical(z,y))){
x = c(sample(0:10, size = 2, replace = TRUE))
y = c(sample(c(0:10), size = 2, replace = TRUE))
z  = c(sample(c(0:10), size = 2, replace = TRUE))
}
plotTYPE(x,y,z)
}
dtr2 <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
tropicalLine <-  function (x,y, tk) {
if (identical(x,y)) {
mu =  (x)
return (mu)
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
mu = ((1-tk)*x+y*tk)
return (mu)
}
if ((x[1] == x[2]) & (y[1] == y[2])){
mu = ((1-tk)*x+y*tk)
return (mu)
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if (tk <= t) {
mu = c(a[1]+tk*(b[1]-a[1]), a[2]+tk*(b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+tk*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= tk) {
mu = c(a[1]+tk*(b[2]-a[2]), a[2]+tk*(b[2]-a[2]))
}
if (t < tk) {
mu = c(b[1],a[2]+tk*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= tk) {
mu = c(a[1],a[2]-tk*(a[2]-b[2]+b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+b[2]-a[2]+tk*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
distances <- function (x,y,z,x1,y1,c1){
t <- seq(0,1, length.out = 467)
distan = matrix(NA, nrow = length(t),ncol = 2)
if (x1[1]>=y1[1]) {
a1 = y1
b1 = x1
}
else {
a1=x1
b1=y1
}
EUsegment = c()
for (i in 1:length(t)){
tk = t[i]
muTR = tropicalLine (x,y,tk)
muE= (1-tk)*a1+b1*tk
EUsegment = rbind(EUsegment, muE)
distan[i,] =  c( dtr2(muTR, z), deu(muE, c1))
}
distan = round(distan , 8)
if ((distan[1,1] ==distan[length(t),2]) & (distan[1,2] ==distan[length(t),1])){
distan[,1] = rev(distan[,1])
}
return (distan)
}
#dist2 = distances(b[-1],c[-1],a[-1],P1[,2],P1[,3],P1[,1])
findEuclidean <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
dab = dtr2(a,b)
dbc = dtr2(b,c)
dac = dtr2(c,a)
a1 = c(0,0)
b1 = c(dab,0)
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 8)) == abs(round(dac, 8))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(xc, yc)
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
curvature <- function (P){
P1 <- findEuclidean(P)
curvS = 0
curvF = 0
sameDist = 0
perm = matrix(c(1,2,3,2,3,1,1,3,2), nrow = 3, byrow = TRUE)
for (j in 1:3){
one = perm[j,1]
two = perm[j,2]
three = perm[j,3]
a = P[,one]
b = P[,two]
c = P[,three]
a1 = P1[,one]
b1 = P1[,two]
c1 = P1[,three]
distan = round(distances (a,b,c,a1,b1,c1), 8)
if (all(distan[,1] == distan[,2])) sameDist = sameDist +1
else if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return ("undefined"))
}
if (sameDist == 3) return (0)
else if ((sameDist+curvS) == 3) return (-1)
else if ((sameDist+curvF) == 3) return (1)
else return ("undefined")
}
plotTR2 <- function (P, cv){
x = P[,1]
y = P[,2]
z = P[,3]
xl = c(min(x[1], y[1], z[1]),max(x[1], y[1], z[1]) )
yl = c(min(x[2], y[2], z[2]),max(x[2], y[2], z[2]) )
trLine = c()
t = seq(0,1, length.out = 200)
for (ti in t){
trLine = rbind(trLine, tropicalLine(x,y,ti))
}
par(mfrow=c(2,2), mar = rep(2, 4))
plot(trLine[,1], trLine[,2], type = 'l', col = 'red', xlim = xl, ylim = yl, main = paste(cv, "2-dim"))
trLine = c()
for (ti in t){
trLine = rbind(trLine, tropicalLine(y,z,ti))
}
lines(trLine[,1], trLine[,2], type = 'l', col = 'blue' )
trLine = c()
for (ti in t){
trLine = rbind(trLine, tropicalLine(x,z,ti))
}
lines(trLine[,1], trLine[,2], type = 'l', col = 'green')
points(x[1], x[2], pch = 16)
points(y[1], y[2], pch = 16)
points(z[1], z[2], pch = 16)
P1 = findEuclidean(P)
distan = distances (x,y,z,P1[,1],P1[,2],P1[, 3])
yl = c(min(distan[,2], distan[,1]), max(distan[,2], distan[,1]))
plot(distan[,2], type = 'l', col = 'blue', main = 'c from a-b', ylim = yl)
lines( distan[,1], type = 'l', col = 'red')
distan = distances (x,z,y,P1[,1],P1[,3],P1[,2])
yl = c(min(distan[,2], distan[,1]), max(distan[,2], distan[,1]))
plot(distan[,2], type = 'l', col = 'blue', main = 'b from a-c', ylim = yl)
lines( distan[,1], type = 'l', col = 'red')
distan = distances (y,z,x,P1[,2],P1[,3],P1[,1])
yl = c(min(distan[,2], distan[,1]), max(distan[,2], distan[,1]))
plot(distan[,2], type = 'l', col = 'blue', main = 'a from b-c', ylim = yl)
lines( distan[,1], type = 'l', col = 'red')
}
for (j in 1:10){
x = sample(0:10, size = 2, replace = TRUE)
y  = sample(c(0:10), size = 2, replace = TRUE)
z  = sample(c(0:10), size = 2, replace = TRUE)
while ((identical(x,y)) | (identical(x,z)) | (identical(z,y))){
x = c(sample(0:10, size = 2, replace = TRUE))
y = c(sample(c(0:10), size = 2, replace = TRUE))
z  = c(sample(c(0:10), size = 2, replace = TRUE))
}
plotTYPE(x,y,z)
}
generateUltra <- function(split) {
delta <- seq(0.41, 2, by = 0.01)
for(i in delta){
if (split = 1){
u1 <- c(0.2,i,2,i,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(0.4,2,2,2,2,0.4)}
if (split == 2){
u1 <- c(0.2,0.4,2,0.4,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(i,2,2,2,2,0.4)
}
D <- rbind(u1,u2,u3)
}
return(D)
}
generateUltra <- function(split) {
delta <- seq(0.41, 2, by = 0.01)
for(i in delta){
if (split == 1){
u1 <- c(0.2,i,2,i,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(0.4,2,2,2,2,0.4)}
if (split == 2){
u1 <- c(0.2,0.4,2,0.4,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(i,2,2,2,2,0.4)
}
D <- rbind(u1,u2,u3)
}
return(D)
}
D = generateUltra(1)
View(D)
generateUltra <- function(split) {
delta <- seq(0.41, 2, by = 0.01)
if (split == 1){
for(i in delta){
u1 <- c(0.2,i,2,i,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(0.4,2,2,2,2,0.4)
D <- rbind(u1,u2,u3)
}
}
if (split == 2){
for(i in delta){
u1 <- c(0.2,0.4,2,0.4,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(i,2,2,2,2,0.4)
D <- rbind(u1,u2,u3)
}
}
return (D)
}
D = generateUltra(1)
generateUltra <- function(split) {
D = c()
delta <- seq(0.41, 2, by = 0.01)
if (split == 1){
for(i in delta){
u1 <- c(0.2,i,2,i,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(0.4,2,2,2,2,0.4)
D <- rbind(D,u1,u2,u3)
}
}
if (split == 2){
for(i in delta){
u1 <- c(0.2,0.4,2,0.4,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(i,2,2,2,2,0.4)
D <- rbind(D,u1,u2,u3)
}
}
return (D)
}
D = generateUltra(1)
generateUltra <- function(split) {
D = c()
delta <- seq(0.41, 2, by = 0.01)
if (split == 1){
for(i in delta){
u1 <- c(0.2,i,2,i,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(0.4,2,2,2,2,0.4)
D <- rbind(D,u1,u2,u3)
}
}
if (split == 2){
for(i in delta){
u1 <- c(0.2,0.4,2,0.4,2,2)
u2 <- c(2,2,2,0.4,0.4,0.2)
u3 <- c(i,2,2,2,2,0.4)
D <- rbind(D,u1,u2,u3)
}
}
return (D)
}
D = generateUltra(1)
D[sample(1:nrow(D)),]
D[sample(1:nrow(D), size = 1),]
dtr <- function (x, y) return (max(x-y) - min(x-y))
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
a = 0
TrSegment = c()
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
b = a+dtr(y1, y2)
t = seq(a,b,by=0.001)
t = t[-length(t)]
segment = c()
if (a == b) a = b
else{
segment = c()
for (i in 1:length(t)){
tk = t[i]
segment =  rbind(segment, (1-(tk-a)/(b-a))*y1+(tk-a)*y2/(b-a))
}
TrSegment = rbind(TrSegment, segment)
}
}
TrSegment = rbind(TrSegment, u)
return (TrSegment)
}
distancesN <- function(a, b, c){
P1 = findEuclideanN(a,b,c)
c1 = P1[,3]
trSeg = trSegmentN(b,a)
n = nrow(trSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
distanN[i,1] = dtr(ptTR, c)
ptEU =  c(dtr(ptTR, a),0)
distanN[i,2] = deu (ptEU, c1)
}
return (distanN)
}
findEuclideanN <- function (a,b,c){
N = length(a)
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = c(0,0)
b1 = c( dab, 0)
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 8)) == abs(round(dac, 8))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c( xc, yc)
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
curvatureN <- function (P){
curvS = 0
curvF = 0
sameDist = 0
perm = matrix(c(1,2,3,2,3,1,1,3,2), nrow = 3, byrow = TRUE)
for (j in 1:3){
one = perm[j,1]
two = perm[j,2]
three = perm[j,3]
a = P[,one]
b = P[,two]
c = P[,three]
distan = round(distancesN (a,b,c), 5)
if (all(distan[,1] == distan[,2])) sameDist = sameDist +1
else if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return ("undefined"))
}
if (sameDist == 3) return (0)
else if ((sameDist+curvS) == 3) return (-1)
else if ((sameDist+curvF) == 3) return (1)
else return ("undefined")
}
plotTRN <- function (P,cv){
a = P[,1]
b = P[,2]
c = P[,3]
xl = c(min(a[2], b[2], c[2]),max(a[2], b[2], c[2]) )
yl = c(min(a[3], b[3], c[3]),max(a[3], b[3], c[3]) )
trSegment = trSegmentN(a,b)
par(mfrow=c(2,2))
plot(trSegment[,2], trSegment[,3], type = 'l', col = 'red', xlim = xl, ylim = yl, main = paste(cv, "N-dim"))
trSegment = trSegmentN(c,b)
lines(trSegment[,2], trSegment[,3], type = 'l', col = 'blue' )
trSegment = trSegmentN(a,c)
lines(trSegment[,2], trSegment[,3], type = 'l', col = 'green')
points(b[2], b[3], pch = 16)
points(c[2], c[3], pch = 16)
points(a[2], a[3], pch = 16)
distan = distancesN (a,b,c)
plot(distan[,2], type = 'l', col = 'blue', main = 'c from a-b')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (a,c,b)
plot(distan[,2], type = 'l', col = 'blue', main = 'b from a-c')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (b,c,a)
plot(distan[,2], type = 'l', col = 'blue', main = 'a from b-c')
lines( distan[,1], type = 'l', col = 'red')
}
plotDistanN <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
par(mfrow=c(1,3))
distan = distancesN (a,b,c)
plot(distan[,2], type = 'l', col = 'blue', main = 'c from a-b')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (a,c,b)
plot(distan[,2], type = 'l', col = 'blue', main = 'b from a-c')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (b,c,a)
plot(distan[,2], type = 'l', col = 'blue', main = 'a from b-c')
lines( distan[,1], type = 'l', col = 'red')
}
curvatures = c()
for (i in 1:100){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
while((identical(a,b)) | (identical(b,c)) | (identical(a,c))){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
}
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvatureN(P))
}
sum(curvatures==0)/length(curvatures)
sum(curvatures==1)/length(curvatures)
sum(curvatures==-1)/length(curvatures)
sum(curvatures=="undefined")/length(curvatures)
curvatures = c()
for (i in 1:100){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
while((identical(a,b)) | (identical(b,c)) | (identical(a,c))){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
}
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvatureN(P))
}
sum(curvatures==0)/length(curvatures)
sum(curvatures==1)/length(curvatures)
sum(curvatures==-1)/length(curvatures)
sum(curvatures=="undefined")/length(curvatures)
curvatures = c()
for (i in 1:100){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
while((identical(a,b)) | (identical(b,c)) | (identical(a,c))){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
}
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvatureN(P))
}
sum(curvatures==0)/length(curvatures)
sum(curvatures==1)/length(curvatures)
sum(curvatures==-1)/length(curvatures)
sum(curvatures=="undefined")/length(curvatures)
curvatures = c()
for (i in 1:1000){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
while((identical(a,b)) | (identical(b,c)) | (identical(a,c))){
a = D[sample(1:nrow(D), size = 1),]
b = D[sample(1:nrow(D), size = 1),]
c = D[sample(1:nrow(D), size = 1),]
}
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvatureN(P))
}
sum(curvatures==0)/length(curvatures)
sum(curvatures==1)/length(curvatures)
sum(curvatures==-1)/length(curvatures)
sum(curvatures=="undefined")/length(curvatures)
i
