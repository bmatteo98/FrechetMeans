P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
curvature <- function (P){
P1 <- findEuclidean(P)
curvS = 0
curvF = 0
sameDist = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distances (a,b,c,a1,b1,c1), 8)
if (all(distan[,1] == distan[,2])) sameDist = sameDist +1
else if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return (0))
}
if ((sameDist+curvS) == 3) return (-1)
if ((sameDist+curvF) == 3) return (1)
else return (0)
}
set.seed(123456)
curvatures = c()
for (i in 1:10){
a = runif(2, min = 0, max = 10)
b = runif(2, min = 0, max = 10)
c = runif(2, min = 0, max = 10)
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvature(P))
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
# same proportions in [-1, 0] and [0,1]
set.seed(123456)
curvatures = c()
for (i in 1:10){
a = runif(2, min = 0, max = 10)
b = runif(2, min = 0, max = 10)
c = runif(2, min = 0, max = 10)
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvature(P))
a = c(0,a)
b  = c(0,b)
c  = c(0,c)
P = matrix(c(a,b, c),nrow=length(a))
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
# same proportions in [-1, 0] and [0,1]
set.seed(123456)
curvatures = c()
for (i in 1:10){
a = runif(2, min = 0, max = 10)
b = runif(2, min = 0, max = 10)
c = runif(2, min = 0, max = 10)
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvature(P))
a = c(0,a)
b  = c(0,b)
c  = c(0,c)
P = matrix(c(a,b, c),nrow=length(a))
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
# same proportions in [-1, 0] and [0,1]
sample(1:10, size = 2, replace = TRUE)
curvatures = c()
for (i in 1:10){
#a = runif(2, min = 0, max = 10)
#b = runif(2, min = 0, max = 10)
#c = runif(2, min = 0, max = 10)
a = sample(1:10, size = 2, replace = TRUE)
b  = sample(1:10, size = 2, replace = TRUE)
c  = sample(1:10, size = 2, replace = TRUE)
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvature(P))
a = c(0,a)
b  = c(0,b)
c  = c(0,c)
P = matrix(c(a,b, c),nrow=length(a))
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
# same proportions in [-1, 0] and [0,1]
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = runif(2, min = 0, max = 10)
#b = runif(2, min = 0, max = 10)
#c = runif(2, min = 0, max = 10)
a = sample(1:10, size = 2, replace = TRUE)
b  = sample(1:10, size = 2, replace = TRUE)
c  = sample(1:10, size = 2, replace = TRUE)
P = matrix(c(a,b, c),nrow=length(a))
curvatures = c(curvatures, curvature(P))
a = c(0,a)
b  = c(0,b)
c  = c(0,c)
P = matrix(c(a,b, c),nrow=length(a))
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
# same proportions in [-1, 0] and [0,1]
plot(3,4)
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = sample(1:10, size = 2, replace = TRUE)
b  = sample(1:10, size = 2, replace = TRUE)
c  = sample(1:10, size = 2, replace = TRUE)
P = matrix(c(a,b, c),nrow=length(a))
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
dtr <- function (x, y) return (max(x-y) - min(x-y))
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
a = 0
TrSegment = matrix(NA, nrow = 1, ncol = N)
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
b = a+dtr(y1, y2)
t = seq(a,b,by=0.01)
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-(tk-a)/(b-a))*y1+(tk-a)*y2/(b-a)
}
TrSegment = rbind(TrSegment, segment)
a = b
}
return (TrSegment[-1,])
}
#trSegment = trSegmentN(c,b)
#plot(trSegment[,2], trSegment[,3], type = 'l', col = 'red')
#trSegment = trSegmentN(c,b)
#plot(trSegment[,1], trSegment[,2], type = 'l')
euclSegmentN <- function(u,v,d){
N = length(u)
a = 0
b = dtr(u,v)
t = seq(a,b,length.out = d)
EuclSegment = matrix(NA, nrow = length(t), ncol = N)
for(i in 1:length(t)){
tk = t[i]
EuclSegment[i,] =  (1-(tk-a)/(b-a))*v+(tk-a)*u/(b-a)
}
return (EuclSegment)
}
euclSegment = euclSegmentN(c1,b1,998)
#plot(euclSegment[,1], euclSegment[,2], type = 'l')
distancesN <- function(a, b, c, a1, b1, c1){
trSeg = trSegmentN(a,b)
euclSeg = euclSegmentN(a1,b1, nrow(trSeg))
#euclSeg = cbind(rep(0,998), EUsegment)
#trSeg = cbind(rep(0,998), trLine)
n = nrow(euclSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
dist = distancesN(b,c,a,b1,c1,a1)
#dist = distancesN(P[,1],P[,2], P[,3], P1[,1], P1[,2],P1[,3] )
findEuclideanN <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
N = length(a)
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = rep(0,N)
b1 = c(0, dab, rep(0, N-2))
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 8)) == abs(round(dac, 8))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(0, xc, yc, rep(0, N-3))
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
#P1 = findEuclidean(P)
curvature <- function (P){
P1 <- findEuclideanN(P)
curvS = 0
curvF = 0
sameDist = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distancesN (a,b,c,a1,b1,c1), 8)
if (all(distan[,1] == distan[,2])) sameDist = sameDist +1
else if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return (0))
}
if ((sameDist+curvS) == 3) return (-1)
if ((sameDist+curvF) == 3) return (1)
else return (0)
}
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = sample(1:10, size = 2, replace = TRUE)
b  = sample(1:10, size = 2, replace = TRUE)
c  = sample(1:10, size = 2, replace = TRUE)
P = matrix(c(a,b, c),nrow=length(a))
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = c(0,sample(1:10, size = 2, replace = TRUE))
b  = c(0,sample(1:10, size = 2, replace = TRUE))
c  = c(0,sample(1:10, size = 2, replace = TRUE))
P = matrix(c(a,b, c),nrow=length(a))
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = c(0,sample(1:10, size = 2, replace = TRUE))
b  = c(0,sample(1:10, size = 2, replace = TRUE))
c  = c(0,sample(1:10, size = 2, replace = TRUE))
P = matrix(c(a,b, c),nrow=length(a))
print(P)
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = c(0,sample(-10:10, size = 2, replace = TRUE))
b  = c(0,sample(-10:10, size = 2, replace = TRUE))
c  = c(0,sample(-10:10, size = 2, replace = TRUE))
P = matrix(c(a,b, c),nrow=length(a))
print(P)
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
a= c(0,-9,3)
b= c(0,4,3)
c = c(0,4,-8)
P = matrix(c(a,b, c),nrow=length(a))
plotTR(P)
distan = distancesN (b,c,a,b1,c1,a1)
plot(distan[,2], type = 'l', col = 'red')
lines( distan[,1], type = 'l')
View(distan)
dtr(a,b)
P1 <- findEuclideanN(P)
a1 = P1[,1]
b1= P1[, 2]
c1 = P1[, 3]
distan = distancesN (b,c,a,b1,c1,a1)
plot(distan[,2], type = 'l', col = 'red')
lines( distan[,1], type = 'l')
View(distan)
distancesN <- function(a, b, c, a1, b1, c1){
trSeg = trSegmentN(a,b)
euclSeg = euclSegmentN(a1,b1, nrow(trSeg))
#euclSeg = cbind(rep(0,998), EUsegment)
#trSeg = cbind(rep(0,998), trLine)
n = nrow(euclSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
if (i ==1) print(ptT)
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
distan = distancesN (b,c,a,b1,c1,a1)
plot(distan[,2], type = 'l', col = 'red')
lines( distan[,1], type = 'l')
distancesN <- function(a, b, c, a1, b1, c1){
trSeg = trSegmentN(a,b)
euclSeg = euclSegmentN(a1,b1, nrow(trSeg))
#euclSeg = cbind(rep(0,998), EUsegment)
#trSeg = cbind(rep(0,998), trLine)
n = nrow(euclSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
if (i ==1) print(ptTR)
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
distan = distancesN (b,c,a,b1,c1,a1)
plot(distan[,2], type = 'l', col = 'red')
lines( distan[,1], type = 'l')
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
a = 0
TrSegment = c()
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
b = a+dtr(y1, y2)
t = seq(a,b,by=0.01)
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-(tk-a)/(b-a))*y1+(tk-a)*y2/(b-a)
}
TrSegment = rbind(TrSegment, segment)
a = b
}
return (TrSegment)
}
trSegment = trSegmentN(c,b)
View(trSegment)
distan = distancesN (b,c,a,b1,c1,a1)
plot(distan[,2], type = 'l', col = 'red')
lines( distan[,1], type = 'l')
trSegment = trSegmentN(b,c)
View(distan)
plotTR(P)
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
a = 0
TrSegment = c()
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
b = a+dtr(y1, y2)
t = seq(a,b,by=0.01)
if (a == b) segment = a
else{
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-(tk-a)/(b-a))*y1+(tk-a)*y2/(b-a)
}
}
TrSegment = rbind(TrSegment, segment)
a = b
}
return (TrSegment)
}
trSegment = trSegmentN(b,c)
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
a = 0
TrSegment = c()
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
b = a+dtr(y1, y2)
t = seq(a,b,by=0.01)
if (a == b) segment = y1
else{
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-(tk-a)/(b-a))*y1+(tk-a)*y2/(b-a)
}
}
TrSegment = rbind(TrSegment, segment)
a = b
}
return (TrSegment)
}
trSegment = trSegmentN(b,c)
View(trSegment)
set.seed(123456)
curvatures = c()
for (i in 1:10){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
a = c(0,sample(-10:10, size = 2, replace = TRUE))
b  = c(0,sample(-10:10, size = 2, replace = TRUE))
c  = c(0,sample(-10:10, size = 2, replace = TRUE))
P = matrix(c(a,b, c),nrow=length(a))
#print(P)
cv = curvature(P)
curvatures = c(curvatures, cv)
if (cv == 0) plotTR(P)
}
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
distancesN <- function(a, b, c, a1, b1, c1){
trSeg = trSegmentN(a,b)
euclSeg = euclSegmentN(a1,b1, nrow(trSeg))
#euclSeg = cbind(rep(0,998), EUsegment)
#trSeg = cbind(rep(0,998), trLine)
n = nrow(euclSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
