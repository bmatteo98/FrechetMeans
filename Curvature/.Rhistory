}
trSegment = trSegmentN(b,c)
#plot(trSegment[,2], trSegment[,3], type = 'l', col = 'red')
#trSegment = trSegmentN(c,b)
#plot(trSegment[,1], trSegment[,2], type = 'l')
euclSegmentN <- function(u,v,d){
N = length(u)
a = 0
b = dtr(u,v)
t = seq(a,b,length.out = d)
EuclSegment = matrix(NA, nrow = length(t), ncol = N)
for(i in 1:length(t)){
tk = t[i]
EuclSegment[i,] =  (1-(tk-a)/(b-a))*v+(tk-a)*u/(b-a)
}
return (EuclSegment)
}
euclSegment = euclSegmentN(c1,b1,998)
#plot(euclSegment[,1], euclSegment[,2], type = 'l')
distancesN <- function(a, b, c, a1, b1, c1){
trSeg = trSegmentN(a,b)
euclSeg = euclSegmentN(a1,b1, nrow(trSeg))
#euclSeg = cbind(rep(0,998), EUsegment)
#trSeg = cbind(rep(0,998), trLine)
n = nrow(euclSeg) # they should be the same
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
dist = distancesN(b,c,a,b1,c1,a1)
#dist = distancesN(P[,1],P[,2], P[,3], P1[,1], P1[,2],P1[,3] )
findEuclideanN <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
N = length(a)
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = rep(0,N)
b1 = c(0, dab, rep(0, N-2))
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 8)) == abs(round(dac, 8))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(0, xc, yc, rep(0, N-3))
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
#P1 = findEuclidean(P)
curvature <- function (P){
P1 <- findEuclideanN(P)
curvS = 0
curvF = 0
sameDist = 0
perm = matrix(c(1,2,3,2,3,1,1,3,2), nrow = 3, byrow = TRUE)
for (j in 1:3){
one = perm[j,1]
two = perm[j,2]
three = perm[j,3]
a = P[,one]
b = P[,two]
c = P[,three]
a1 = P1[,one]
b1 = P1[,two]
c1 = P1[,three]
distan = round(distancesN (a,b,c,a1,b1,c1), 8)
if (all(distan[,1] == distan[,2])) sameDist = sameDist +1
else if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return ("undefined"))
}
if (sameDist == 3) return (0)
else if ((sameDist+curvS) == 3) return (-1)
else if ((sameDist+curvF) == 3) return (1)
else return ("undefined")
}
plotTRN <- function (P,cv){
a = P[,1]
b = P[,2]
c = P[,3]
xl = c(min(a[2], b[2], c[2]),max(a[2], b[2], c[2]) )
yl = c(min(a[3], b[3], c[3]),max(a[3], b[3], c[3]) )
trSegment = trSegmentN(a,b)
par(mfrow=c(2,2))
plot(trSegment[,2], trSegment[,3], type = 'l', col = 'red', xlim = xl, ylim = yl, main = cv)
trSegment = trSegmentN(c,b)
lines(trSegment[,2], trSegment[,3], type = 'l', col = 'blue' )
trSegment = trSegmentN(a,c)
lines(trSegment[,2], trSegment[,3], type = 'l', col = 'green')
points(b[2], b[3], pch = 16)
points(c[2], c[3], pch = 16)
points(a[2], a[3], pch = 16)
P1 = findEuclideanN(P)
distan = distancesN (a,b,c,P1[,1],P1[,2],P1[, 3])
plot(distan[,2], type = 'l', col = 'blue', main = 'c from a-b')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (a,c,b,P1[,1],P1[,3],P1[,2])
plot(distan[,2], type = 'l', col = 'blue', main = 'b from a-c')
lines( distan[,1], type = 'l', col = 'red')
distan = distancesN (b,c,a,P1[,2],P1[,3],P1[,1])
plot(distan[,2], type = 'l', col = 'blue', main = 'a from b-c')
lines( distan[,1], type = 'l', col = 'red')
}
curvatures = c()
for (P in Ps){
#a = c(0,runif(2, min = 0, max = 10))
#b = c(0,runif(2, min = 0, max = 10))
#c = c(0,runif(2, min = 0, max = 10))
#a = c(0,sample(-10:10, size = 2, replace = TRUE))
#b = c(0,sample(-10:10, size = 2, replace = TRUE))
#c  = c(0,sample(-10:10, size = 2, replace = TRUE))
#P = matrix(c(a,b, c),nrow=length(a))
#print(P)
Pz = rbind(rep(0,3), P)
cv = curvature(Pz)
curvatures = c(curvatures, cv)
print(Pz)
plotTRN(Pz, cv)
}
plot(1,1)
sum(curvatures==0)/length(curvatures) #0.645 # 0.6653
sum(curvatures==1)/length(curvatures) #0.282 # 0.246
sum(curvatures==-1)/length(curvatures) #0.073 #0.0887
sum(curvatures=="undefined")/length(curvatures)
# same proportions in [-1, 0] and [0,1]
a = c(0,0)
b = c(2,4)
c = c(5,1)
P<- matrix(c(a,b, c),nrow=length(a))
K = 100000
N = 10
epsilon = 0.0001
dtr <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
de <- function (x, y) return (sqrt(sum((x-y)^2)))
sosd <- function (d, mu, P) {
sos = 0
for (i in 1:ncol(P)){
x = P[,i]
sos = sos + d(x,mu)^2
}
return (sos)
}
tropicalLine <-  function (x,y, tk) {
if (identical(x,y)) {
mu =  (x)
return (mu)
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
mu = ((1-tk)*x+y*tk)
return (mu)
}
if ((x[1] == x[2]) & (y[1] == y[2])){
mu = ((1-tk)*x+y*tk)
return (mu)
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if (tk <= t) {
mu = c(a[1]+tk*(b[1]-a[1]), a[2]+tk*(b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+tk*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= tk) {
mu = c(a[1]+tk*(b[2]-a[2]), a[2]+tk*(b[2]-a[2]))
}
if (t < tk) {
mu = c(b[1],a[2]+tk*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= tk) {
mu = c(a[1],a[2]-tk*(a[2]-b[2]+b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+b[2]-a[2]+tk*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
FrechetStrum <- function (P, K, N, epsilon){
mu = P[,sample(ncol(P),size=1)]
d = c()
for (k in 1:K){
p = P[,sample(ncol(P),size=1)]
muk=mu
tk = 1/(k+1)
mu = tropicalLine(muk, p, tk )
d = c(d, de(muk, mu))
ld = length(d)
if (ld>N){
if (all(d[c((ld-N):ld )]<epsilon) ) {
return (c(mu, sosd(dtr, mu, P)))
}
}
}
crit = 0
return (c("out for iterations:", mu))
}
FrechetStrum(P, K, N, epsilon)
inductive_mean <- function (x,y,k) {
if (identical(x,y)) {
return (x)
break
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[2] == y[1]) | (x[1] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[1] == x[2]) | (y[1] == y[2])){
return ((1-1/k)*x+y/k)
break
}
if ((x[1] == x[2]) & (y[1] == y[2])){
return ((1-1/k)*x+y/k)
break
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if ((1/k) <= t) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), a[2]+(1/k)*(b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= (1/k)) {
mu = c(a[1]+(1/k)*(b[2]-a[2]), a[2]+(1/k)*(b[2]-a[2]))
}
if (t < (1/k)) {
mu = c(b[1],a[2]+(1/k)*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= (1/k)) {
mu = c(a[1],a[2]-(1/k)*(a[2]-b[2]+b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+b[2]-a[2]+(1/k)*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
FrechetStrum <- function (P, K, N, epsilon){
mu = P[,sample(ncol(P),size=1)]
d = c()
for (k in 1:K){
p = P[,sample(ncol(P),size=1)]
muk=mu
tk = 1/(k+1)
#mu = tropicalLine(muk, p, tk )
mu = inductive_mean(muk, p, k+1 )
d = c(d, de(muk, mu))
ld = length(d)
if (ld>N){
if (all(d[c((ld-N):ld )]<epsilon) ) {
return (c(mu, sosd(dtr, mu, P)))
}
}
}
crit = 0
return (c("out for iterations:", mu))
}
FrechetStrum(P, K, N, epsilon)
inductive_mean <- function (x,y,k) {
if (identical(x,y)) {
return (x)
break
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[2] == y[1]) | (x[1] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[1] == x[2]) & (y[1] == y[2])){
return ((1-1/k)*x+y/k)
break
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if ((1/k) <= t) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), a[2]+(1/k)*(b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= (1/k)) {
mu = c(a[1]+(1/k)*(b[2]-a[2]), a[2]+(1/k)*(b[2]-a[2]))
}
if (t < (1/k)) {
mu = c(b[1],a[2]+(1/k)*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= (1/k)) {
mu = c(a[1],a[2]-(1/k)*(a[2]-b[2]+b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+b[2]-a[2]+(1/k)*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
FrechetStrum <- function (P, K, N, epsilon){
mu = P[,sample(ncol(P),size=1)]
d = c()
for (k in 1:K){
p = P[,sample(ncol(P),size=1)]
muk=mu
tk = 1/(k+1)
#mu = tropicalLine(muk, p, tk )
mu = inductive_mean(muk, p, k+1 )
d = c(d, de(muk, mu))
ld = length(d)
if (ld>N){
if (all(d[c((ld-N):ld )]<epsilon) ) {
return (c(mu, sosd(dtr, mu, P)))
}
}
}
crit = 0
return (c("out for iterations:", mu))
}
FrechetStrum(P, K, N, epsilon)
inductive_mean <- function (x,y,k) {
if (identical(x,y)) {
return (x)
break
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[2] == y[1]) | (x[1] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[1] == x[2]) & (y[1] == y[2])){
return ((1-1/k)*x+y/k)
break
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if ((1/k) <= t) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), a[2]+(1/k)*(b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= (1/k)) {
mu = c(a[1]+(1/k)*(b[2]-a[2]), a[2]+(1/k)*(b[2]-a[2]))
}
if (t < (1/k)) {
mu = c(b[1],a[2]+(1/k)*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= (1/k)) {
mu = c(a[1],a[2]-(1/k)*(a[2]-b[2]+b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+b[2]-a[2]+(1/k)*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
inductive_mean <- function (x,y,k) {
if (identical(x,y)) {
return (x)
break
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[2] == y[1]) | (x[1] == y[2])) {
return ((1-1/k)*x+y/k)
break
}
if ((x[1] == x[2]) & (y[1] == y[2])){
return ((1-1/k)*x+y/k)
break
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if ((1/k) <= t) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), a[2]+(1/k)*(b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+(1/k)*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= (1/k)) {
mu = c(a[1]+(1/k)*(b[2]-a[2]), a[2]+(1/k)*(b[2]-a[2]))
}
if (t < (1/k)) {
mu = c(b[1],a[2]+(1/k)*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= (1/k)) {
mu = c(a[1],a[2]-(1/k)*(a[2]-b[2]+b[1]-a[1]))
}
if (t < (1/k)) {
mu = c(a[1]+b[2]-a[2]+(1/k)*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
#inductive_mean(c(0,0), c(2,7), 3)
FrechetStrum <- function (P, K, N, epsilon){
mu = P[,sample(ncol(P),size=1)]
d = c()
for (k in 1:K){
p = P[,sample(ncol(P),size=1)]
muk=mu
tk = 1/(k+1)
#mu = tropicalLine(muk, p, tk )
mu = inductive_mean(muk, p, k+1 )
d = c(d, de(muk, mu))
ld = length(d)
if (ld>N){
if (all(d[c((ld-N):ld )]<epsilon) ) {
return (c(mu, sosd(dtr, mu, P)))
}
}
}
crit = 0
return (c("out for iterations:", mu))
}
FrechetStrum(P, K, N, epsilon)
a = c(0,0)
b = c(2,4)
c = c(5,1)
P<- matrix(c(a,b, c),nrow=length(a))
K = 100000
N = 10
epsilon = 0.0001
FrechetStrum(P, K, N, epsilon)
