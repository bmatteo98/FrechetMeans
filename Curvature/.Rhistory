curvS = 0
curvF = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distancesN (a,b,c,a1,b1,c1), 5)
if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return (0))
}
if (curvS == 3) return (-1)
if (curvF == 3) return (1)
else return (0)
}
P = matrix(c(c(0,a),c(0,b),c(0,c)),nrow=length(a))
P1 <- findEuclideanN(P)
distan = distancesN (c(0,a),c(0,b),c(0,c),P1[,1],P1[, 2],P1[, 3])
P = matrix(c(c(0,a),c(0,b),c(0,c)),nrow=length(a+1))
P = matrix(c(c(0,a),c(0,b),c(0,c)),nrow=length(3))
P = matrix(c(0,a),c(0,b),c(0,c),nrow=length(3))
a = c(0,a)
b = c(0,b)
c = c(0,c)
P = matrix(a,b,c,nrow=length(a))
View(P)
P = matrix(c(a,b, c),nrow=length(a))
curvature(P)
P1 <- findEuclideanN(P)
a1 = P1[,1]
b1= P1[, 2]
c1 = P1[, 3]
distan = distancesN (a,b,c,P1[,1],P1[, 2],P1[, 3])
#t = seq(0,1, length.out = nrow(distan))
plot( distan[,1], type = 'l', col = 'red')
lines(distan[,2], type = 'l', col = 'red')
dtr <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
tropicalLine <-  function (x,y, tk) {
if (identical(x,y)) {
mu =  (x)
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
mu = ((1-tk)*x+y*tk)
}
if ((x[1] == x[2]) | (y[1] == y[2])){
mu = ((1-tk)*x+y*tk)
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if (tk <= t) {
mu = c(a[1]+tk*(b[1]-a[1]), a[2]+tk*(b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+tk*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= tk) {
mu = c(a[1]+tk*(b[2]-a[2]), a[2]+tk*(b[2]-a[2]))
}
if (t < tk) {
mu = c(b[1],a[2]+tk*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= tk) {
mu = c(a[1],a[2]-tk*(a[2]-b[2]+b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+b[2]-a[2]+tk*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
distances <- function (a,b,c,x1,y1,c1){
t <- seq(0,1, by= 0.01)
distan = matrix(NA, nrow = length(t),ncol = 2)
if (x1[1]>=y1[1]) {
a1 = y1
b1 = x1
}
else {
a1=x1
b1=y1
}
for (i in 1:length(t)){
tk = t[i]
muTR = tropicalLine (a,b,tk)
muE= (1-tk)*a1+b1*tk
distan[i,] =  c(deu(muE, c1), dtr(muTR, c))
}
distan = round(distan , 7)
if ((distan[1,1] ==distan[length(t),2]) & (distan[1,2] ==distan[length(t),1])){
distan[,1] = rev(distan[,1])
}
return (distan)
}
findEuclidean <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = c(0,0)
b1 = c(dab,0)
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 5)) == abs(round(dac, 5))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(xc, yc)
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
curvature <- function (P){
P1 <- findEuclidean(P)
curvS = 0
curvF = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distances (a,b,c,a1,b1,c1), 5)
if (all(distan[,1] <= distan[,2])) curvF = curvF +1
else if (all(distan[,1] >= distan[,2])) curvS = curvS +1
else (return (0))
}
if (curvS == 3) return (-1)
if (curvF == 3) return (1)
else return (0)
}
a = runif(2, min = -1, max = 0)
b = runif(2, min = -1, max = 0)
c = runif(2, min = -1, max = 0)
P = matrix(c(a,b, c),nrow=length(a))
curvature(P)
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
#print(L)
t = seq(0,1,length.out = 100)
TrSegment = matrix(NA, nrow = 1, ncol = N)
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-tk)*y1+tk*y2
}
TrSegment = rbind(TrSegment, segment)
}
return (TrSegment[-1,])
}
#trSegment = trSegmentN(c,b)
#plot(trSegment[,1], trSegment[,2], type = 'l')
euclSegmentN <- function(u,v){
N = length(u)
t = seq(0,1, length.out = 100*(N-1))
EuclSegment = matrix(NA, nrow = length(t), ncol = N)
for(i in 1:length(t)){
tk = t[i]
EuclSegment[i,] =  (1-tk)*v+tk*u
}
return (EuclSegment)
}
#euclSegment = euclSegmentN(c,b)
#plot(euclSegment[,1], euclSegment[,2], type = 'l')
dtr <- function (x, y) return (max(x-y) - min(x-y))
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
distancesN <- function(a, b, c, a1, b1, c1){
euclSeg = euclSegmentN(a1,b1)
trSeg = trSegmentN(a,b)
n = nrow(euclSeg)
distanN = matrix(NA, nrow = n, ncol = 2)
for (i in 1: n){
ptTR = trSeg[i,]
ptEU = euclSeg[i,]
distanN[i,] = c(dtr(ptTR, c), deu(ptEU, c1))
}
return (distanN)
}
#dist = distancesN(P[,1],P[,2], P[,3], P1[,1], P1[,2],P1[,3] )
findEuclideanN <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
N = length(a)
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = rep(0,N)
b1 = c(dab, rep(0, N-1))
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 5)) == abs(round(dac, 5))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(xc, yc, rep(0, N-2))
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
#P1 = findEuclidean(P)
curvature <- function (P){
P1 <- findEuclideanN(P)
curvS = 0
curvF = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distancesN (a,b,c,a1,b1,c1), 5)
if (all(distan[,1] <= distan[,2])) curvS = curvS +1
else if (all(distan[,1] >= distan[,2])) curvF = curvF +1
else (return (0))
}
if (curvS == 3) return (-1)
if (curvF == 3) return (1)
else return (0)
}
a = c(0,a)
b = c(0,b)
c = c(0,c)
P = matrix(c(a,b, c),nrow=length(a))
curvature(P)
distan = distancesN (a,b,c,P1[,1],P1[, 2],P1[, 3])
#t = seq(0,1, length.out = nrow(distan))
plot( distan[,1], type = 'l', col = 'red')
lines(distan[,2], type = 'l', col = 'red')
P1 <- findEuclideanN(P)
distan = distancesN (a,b,c,P1[,1],P1[, 2],P1[, 3])
#t = seq(0,1, length.out = nrow(distan))
plot( distan[,1], type = 'l', col = 'red')
lines(distan[,2], type = 'l', col = 'red')
dtr <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
deu <- function (x, y) return (sqrt(sum((x-y)^2)))
tropicalLine <-  function (x,y, tk) {
if (identical(x,y)) {
mu =  (x)
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
mu = ((1-tk)*x+y*tk)
}
if ((x[1] == x[2]) | (y[1] == y[2])){
mu = ((1-tk)*x+y*tk)
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if (tk <= t) {
mu = c(a[1]+tk*(b[1]-a[1]), a[2]+tk*(b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+tk*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= tk) {
mu = c(a[1]+tk*(b[2]-a[2]), a[2]+tk*(b[2]-a[2]))
}
if (t < tk) {
mu = c(b[1],a[2]+tk*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= tk) {
mu = c(a[1],a[2]-tk*(a[2]-b[2]+b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+b[2]-a[2]+tk*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
distances <- function (a,b,c,x1,y1,c1){
t <- seq(0,1, by= 0.01)
distan = matrix(NA, nrow = length(t),ncol = 2)
if (x1[1]>=y1[1]) {
a1 = y1
b1 = x1
}
else {
a1=x1
b1=y1
}
for (i in 1:length(t)){
tk = t[i]
muTR = tropicalLine (a,b,tk)
muE= (1-tk)*a1+b1*tk
distan[i,] =  c(deu(muE, c1), dtr(muTR, c))
}
distan = round(distan , 7)
if ((distan[1,1] ==distan[length(t),2]) & (distan[1,2] ==distan[length(t),1])){
distan[,1] = rev(distan[,1])
}
return (distan)
}
findEuclidean <- function (P){
a = P[,1]
b = P[,2]
c = P[,3]
dab = dtr(a,b)
dbc = dtr(b,c)
dac = dtr(c,a)
a1 = c(0,0)
b1 = c(dab,0)
xc = (dac^2-dbc^2+dab^2)/(2*dab)
if (abs(round(xc, 5)) == abs(round(dac, 5))) yc = 0
else yc = sqrt(dac^2-xc^2)
c1 = c(xc, yc)
P1 <- matrix(c(a1,b1, c1),nrow=length(a1))
return (P1)
}
curvature <- function (P){
P1 <- findEuclidean(P)
curvS = 0
curvF = 0
for (j in 1:ncol(P)){
a = P[,j%%ncol(P)+1]
b = P[,(j+1)%%ncol(P)+1]
c = P[,(j+2)%%ncol(P)+1]
a1 = P1[,j%%ncol(P1)+1]
b1 = P1[,(j+1)%%ncol(P1)+1]
c1 = P1[,(j+2)%%ncol(P1)+1]
distan = round(distances (a,b,c,a1,b1,c1), 5)
if (all(distan[,1] <= distan[,2])) curvF = curvF +1
else if (all(distan[,1] >= distan[,2])) curvS = curvS +1
else (return (0))
}
if (curvS == 3) return (-1)
if (curvF == 3) return (1)
else return (0)
}
#P is the tropical triangle
P<- matrix(c(a[-1],b[-1], c[-1]),nrow=length(a))
P1 <- findEuclidean(P)
distan = distances (a[-1],b[-1],c[-1],P1[,1],P1[, 2],P1[, 3])
#P is the tropical triangle
P<- matrix(c(a[-1],b[-1], c[-1]),ncol=length(a))
P1 <- findEuclidean(P)
distan = distances (a[-1],b[-1],c[-1],P1[,1],P1[, 2],P1[, 3])
t <- seq(0,1, by= 0.01)
plot(t, distan[,2], type = 'l')
lines(t, distan[,1], type = 'l')
tropicalLine <-  function (x,y, tk) {
if (identical(x,y)) {
mu =  (x)
}
if ((x[1] == y[1]) | (x[2] == y[2])) {
mu = ((1-tk)*x+y*tk)
}
if ((x[1] == x[2]) | (y[1] == y[2])){
mu = ((1-tk)*x+y*tk)
}
if (x[1]<y[1]) {
a = x
b = y
}
if (x[1]>y[1]) {
a = y
b = x
}
if ((a[2]<b[2]) & ((a[1]-a[2])<=(b[1]-b[2]))){
t = (b[2]-a[2])/(b[1]-a[1])
if (tk <= t) {
mu = c(a[1]+tk*(b[1]-a[1]), a[2]+tk*(b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+tk*(b[1]-a[1]), b[2])
}
}
if ((a[2]<b[2]) & ((a[1]-a[2])>(b[1]-b[2]))){
t = (b[1]-a[1])/(b[2]-a[2])
if (t >= tk) {
mu = c(a[1]+tk*(b[2]-a[2]), a[2]+tk*(b[2]-a[2]))
}
if (t < tk) {
mu = c(b[1],a[2]+tk*(b[2]-a[2]))
}
}
if (a[2]>b[2]){
t = (a[2]-b[2])/(a[2]-b[2]+b[1]-a[1])
if (t >= tk) {
mu = c(a[1],a[2]-tk*(a[2]-b[2]+b[1]-a[1]))
}
if (t < tk) {
mu = c(a[1]+b[2]-a[2]+tk*(a[2]-b[2]+b[1]-a[1]),b[2])
}
}
return (mu)
}
trLine = c()
t = seq(0,1, by = 0.01)
for (ti in t){
trLine = cbind(trLine, tropicalLine(a,b,ti))
}
plot(trLine[1,], trLine[2,], type = 'l')
trLine = c()
t = seq(0,1, by = 0.01)
for (ti in t){
trLine = cbind(trLine, tropicalLine(a[-1],b[-1],ti))
}
plot(trLine[1,], trLine[2,], type = 'l')
trSegmentN <- function (u, v){
N = length(u)
lambda = v-u
#print(lambda)
sortLambda = sort(lambda)
L = matrix(NA, nrow = N, ncol = N)
y = v
L[1,] = y
for (i in 2:(N-1)){
li = sortLambda[i]
y = pmin(u + li,v )
y = y - y[1]
L [i,] = y
}
L[N,] = u
#print(L)
t = seq(0,1,length.out = 100)
TrSegment = matrix(NA, nrow = 1, ncol = N)
for (j in 1:(N-1)){
y1 = L[j,]
y2 = L[j+1,]
segment = matrix(NA, nrow = length(t), ncol = N)
for (i in 1:length(t)){
tk = t[i]
segment[i,] =  (1-tk)*y1+tk*y2
}
TrSegment = rbind(TrSegment, segment)
}
return (TrSegment[-1,])
}
trSegment = trSegmentN(a,b)
lines(trSegment[,2], trSegment[,3], type = 'l', col = 'red')
point(c[-1], phc = 16)
points(c[-1], phc = 16)
points(c[2], c[3], phc = 16)
View(trLine)
View(trSegment)
dtr <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
dtr(pt,c[-1])
c
dtr(pt,c(-0.5606527 -0.7082600))
pt = c(-0.9718798,-0.5272726)
dtr(pt,c(-0.5606527 -0.7082600))
dtr <- function (x, y){
x = c(0,x)
y = c(0,y)
return (max(x-y) - min(x-y))
}
dtr(c(-0.9718798,-0.5272726),c(-0.5606527 -0.7082600))
c(-0.9718798,-0.5272726)-c(-0.5606527 -0.7082600)
pt
c
c[-1]
pt-c[-1]
dtr(c(0,1), c(2,1))
dtr(c(-0.9718798,-0.5272726), c(-0.5606527 -0.7082600))
dtr(c(-0.9718798,-0.5272726), c(-0.5606527, -0.7082600))
dtr <- function (x, y) return (max(x-y) - min(x-y))
dtr(c(0,-0.9718798,-0.5272726), c(0,-0.5606527, -0.7082600))
